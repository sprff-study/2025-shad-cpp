# Range Map

В этой задаче вам нужно реализовать структуру данных, которая хранит значения по ключу. В отличии от привычного `std::map` ключ в данной структуре хранится в виде диапазона и соответствующее значение приписывается любому элементу этого диапазона.

Левая граница диапазона строго меньше правой границы.

Для понимание рассмотрим пример:
```cpp
RangeMap map;
map.Insert({1, 5}, 1);  // {1, 5} - это ключ, 1 - значение
assert(map.Get(1) == 1);
assert(map.Get(3) == 1);  // 3 принадлежит [1, 5)
map.Insert({8, 10}, 2);
assert(map.Size() == 2uz);  // [1, 5) -> 1, [8, 10) -> 2
map.Insert({3, 8}, 3);
assert(map.Size() == 3uz);  // [1, 3) -> 1, [3, 8} ->3, [8, 10) -> 2
```

Класс должен уметь работать с произвольными типами ключей и значений. Интерфейс вы можете найти в файле [`range_map.h`](range_map.h). Вам нужно будет реализовать:
* Конструктор по умолчанию.
* Конструктор, принимающий список инициализации `initializer_list<pair<pair<K, K>, V>>`, чтобы можно было создать непустой контейнер `RangeMap<int, int> map({{{1, 2}, 1}, {{2, 3}, 2}, {{3, 4}, 3}});`. Проверять корректность переданных интервалов не нужно.
* Метод `Insert`, принимающий диапазон и значение, которое будет присвоено всем элементам данного диапазона. Если переданный диапазон не валиден, то выбрасывается исключение.
* Метод `Remove`, принимающий диапазон, значения которого нужно удалить из контейнера.
* Метод `Size`, возвращающий число интералов (ключей).
* Метод `Clear`, который почистит контейнер. После вызова этого метода `Size` должен стать нулевым.
* Метод `Empty`, возвращающий `true`, если контейнер пуст, и `false` иначе.
* Метод `Contains`, принимающий единственное значение ключа и проверяющий, содержится ли оно в контейнере.
* Метод `Get`, принимающий единственное значение ключа и возвращающий значение по этому ключу. Если такого ключа в контейнере нет, то выбрасывается исключение.

### Примечания
* Используйте `std::map` и в качестве ключа храните пару.
* Не храните каждый ключ диапазона отдельно.
