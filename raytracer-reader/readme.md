# Чтение сцены

Это вторая подзадача [домашнего задания про рейтрейсер](../raytracer). В рамках этой задачи вам нужно научиться читать `.obj` файлы, в которых задается сцена для рейтрейсера. Структура таких файлов описана [здесь](https://en.wikipedia.org/wiki/Wavefront_.obj_file). В нашем случае достаточно строчек с `v, vn, f, mtllib, usemtl`. Нумерация сущностей в `f` **глобальная**.

Некоторые замечания:
* В `f` может быть задано произвольное число вершин, но вы можете сразу нарезать такой многоугольник на треугольники $`(\mathrm{P_0, P_i, P_{i+1}})`$, где $`\mathrm{i}`$ пробегает по вершинам многоугольника.
* Необходимо поддерживать **все возможные** варианты задания вершин в `f` (с индексом нормали и/или текстуры или пропуском соответственно). При этом саму поддержку текстурирования делать не нужно.
* Гарантируется, что файл, определенный в `mtllib`, находится в той же директории, что и `.obj` файл.
* Для удобства в нашем задании также нужно уметь обрабатывать строчки вида `S x y z r`. Такая строка задает сферу с центром в `(x, y, z)` радиуса `r`.
* Помимо этого нужно обрабатывать строки вида `P x y z r g b`. Такая строка задает точечный источник света с координатами `(x, y, z)`, имеющий интенсивность `(r, g, b)`. **Обратите внимание**, что `(r, g, b)` необязательно лежат в диапазоне `[0,1]`.

Касательно `.mtl` файлов описание приведено там же по ссылке выше, но есть следующие нюансы:

* Необходимо поддерживать строки с `newmtl, Ka, Kd, Ks, Ns, Ni`. Все остальное нужно игнорировать.
* Нужно поддержать нестандартный модификатор `Ke (intensity)`. В нашем задании его нужно обрабатывать так же, как и `Ka`, т.е. как аддитивную прибавку к суммарному освещению объекта.
* Нужно поддерживать дополнительный модификатор `al a b c` (`albedo`), задающий светоотражающие характеристики материала. Как они учитываются в вычислении освещения описано в основном задании. Если модификатор не задан, то по умолчанию значения должны быть `al 1 0 0`.

### Сцена
Основную часть задания предстоит реализовать в файле [`scene.h`](scene.h), но постарайтесь декомпозировать свой код. Вам же будет легче дебажить.

Сцена хранит в себе всё, что вы прочитали из `.obj` файла: вершины, нормали, геометрические объекты, источники света и материалы.

Чтобы можно было прочитать сцену, реализуйте функцию `ReadScene`. Ей на вход приходит путь до `.obj` файла. Обратите внимание на [std::filesystem](https://en.cppreference.com/w/cpp/header/filesystem.html). Для чтения файла используйте стандартные [файловые потоки ввода](https://en.cppreference.com/w/cpp/io/basic_ifstream.html).

#### Объекты
[Геометрические объекты](object.h) бывают 2-х типов: `Object` (треугольник) и `SphereObject` (сфера). Посмтрите их интерфейс. Помимо самого объекта, в структуре есть указатель на [`Material`](material.h). Указатель нужен, потому что сами материалы хранятся в `Scene` и дополнительно копировать их в объекты не стоит. Проследите, чтобы указатели не становились висячими. `std::unordered_map` гарантирует, что пока элемент не удалили, ссылки и указатели на него остаются валидными.

#### Материалы
Материалы определены в `.mtl` файле. Его чтение инициализирует строчка в `.obj` файле, которая начинается с `mtllib` (далее следует название `.mtl` файла). Для чтения файла материалов реализуйте функцию `ReadMaterials`.

Обратите внимание, что в сцене есть метод `GetMaterials`, который возвращает `std::unordered_map<std::string, Material>`. Ключом здесь является название материала (следует за `newmtl` в файле), а значение - структура, которую можете найти [здесь](material.h). Соответствие следующее: `ambient_color (Ka), diffuse_color (Kd), specular_color (Ks), intensity (Ke), albedo (al, default: (1, 0,0)), specular_exponent (Ns, default: 1), refraction_index (Ni, default: 1)`.


### Примечания
* Функции-геттеры класса `Scene` должны возвращать объекты в том порядке, в котором они заданы в файле. 
