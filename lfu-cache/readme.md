# LFU Cache

В этой задаче вам нужно реализовать шаблонный ассоциативный контейнер фиксированного размера. Вытеснение должно работать по принципу "Least Frequently Used (LFU)".
Интерфейс находится в файле [`lfu_cache.h`](lfu_cache.h).

Пока размер кеша не превышает максимальный, он работает как обычный `map`:
* Метод `Set(key, value)` приписывает новое значение соответствующее ключу.
* Метод `Get(key)` возвращает значение по ключу. Если ключа в контейнере нет, то бросается исключение.
* Метод `Erase(key)` возвращает `true`, удаляя пару (ключ, значение) из контейнера. Если ключа в контейнере нет, то возвращает `false` и больше ничего не делает.

Если после `Set()` размер кеша превышает `capacity`, то срабатывает алгоритм вытеснения. Для стратегии LFU он следующий:
* вытесняется наименее часто используемый элемент (частота измеряется количеством вызовов методов `Set` и `Get`);
* если таких элементов несколько, то вытесняется наименее недавно используемый (как в "Least Recently Used (LRU)").

Вычислительная сложность методов `Get()` и `Set()` должна быть `O(1)` в среднем.

### Пример
Для кэша `размера 3`. Рассмотрим последовательность обращений по ключу. Для простоты, если ключа не было ранее - это `Set`, иначе `Get`.
```bash
1 2 3 1 1 1 1 1 2 3 4
# 1 2 3 -> [1, 2, 3]
# 1 -> [2, 3, 1]
# 2 3 -> [1, 2, 3]
# В LRU стратегии 4 вытеснит 1, в LFU freq(1) > freq(2, 3), поэтому 1 не будет вытеснена.
```

<details>
  <summary>Не раскрывайте этот спойлер, если хотите решить эту задачу сами и без подсказок</summary>
  Сами элементы лучше всего хранить в [двусвязном списке](https://en.cppreference.com/w/cpp/container/list.html).
  Вам также потребуются ассоциативные контейнеры [unordered_map](https://en.cppreference.com/w/cpp/container/unordered_map.html)/[map](https://en.cppreference.com/w/cpp/container/map.html), в которых будут храниться итераторы списка (`list::iterator`).
</details>
