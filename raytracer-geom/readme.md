# Геометрия

Это первая подзадача [домашнего задания про рейтрейсер](../raytracer).
В рамках этой задачи вам предстоит реализовать все необходимые геометрические примитивы,
которые потребуются рейтрейсеру.

Начните с основных геометрических объектов.

### Vector
[`vector.h`](vector.h) описывает класс **трёхмерного** вектора. Для представления координат используется `std:array`. Создание `std::array` практически бесплатно по сравнению с `std::vector`, а в рейтрейсере нужно создавать много векторов, поэтому важно использовать именно этот контейнер во избежание сильного падения производительности.

Помимо самого вектора реализуйте вспомогательные функции:
* `DotProduct` - скалярное произведение двух векторов
* `CrossProduct` - векторное произведение двух векторов
* `Length` - длина вектора

### Triangle
[`triangle.h`](triangle.h) описывает класс треугольника. Треугольник задайте через координаты 3-х его вершин (для самих координат используйте описанный ранее класс `Vector`). Для вычисления площади треугольника воспользуйтесь векторным произведением.

### Ray
[`ray.h`](ray.h) описывает класс луча. Луч имеет начало и направление. **Важно**: направление должно быть нормализованным вектором, чтобы в дальнейшем не было ошибок.

### Sphere
[`sphere.h`](sphere.h) описывает класс сферы. Сфера имеет центр и радиус.

### Intersection
[`intersection.h`](intersection.h) описывает класс пересечения луча и другого геометрического объекта.
* `position` - координата первичной точки пересечения
* `normal` - нормаль к поверхности геометрического объекта в точке пересечения; направление нормали зависит от взаимного положения луча и объекта. Если нормаль (внешняя нормаль в случае сферы) к поверхности объекта в точке пересечения и луч сонаправлены, то выбирается противоположное направление нормали.
* `distance` - расстояние от начала луча до точки пересечения

После того как реализовали примитивы, приступайте к геометрии ([`geometry.h`](`geometry.h`)).

### Геометрия
* `GetIntersection` - функции для вычисления пересечения луча и треугольника(сферы). Если пересечения нет, то в результате `std::nullopt`. Для нахождения пересечения луча и треугольника можно воспользоваться [алгоритмом](https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm).
* `Reflect` - функция для вычисления отраженного луча в точке, нормаль в которой равна `normal`. [Формула](https://registry.khronos.org/OpenGL-Refpages/gl4/html/reflect.xhtml) для вычисления отражённого луча.
* `Refract` - функция для вычисления преломленного луча в точке, нормаль в которой равна `normal`. Параметр `eta` равен $`\mathrm{\frac{n_1}{n_2}}`$, где $`\mathrm{n_i}`$ - показатель преломления среды, из которой идет луч ($`\mathrm{n_1}`$), и среды, в которую он идет ($`\mathrm{n_2}`$). [Формула](https://registry.khronos.org/OpenGL-Refpages/gl4/html/refract.xhtml) для вычисления отражённого луча.
* `GetBarycentricCoords`, вычисляющую [барицентрические координаты](https://en.wikipedia.org/wiki/Barycentric_coordinate_system) точки относительно заданного треугольника (гарантируется, что точка лежит внутри или на границе треугольника).

### Полезное
* для модуля дробных чисел используйте [`std::fabs`](https://en.cppreference.com/w/cpp/numeric/math/fabs.html)
