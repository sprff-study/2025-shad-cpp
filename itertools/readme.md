# Itertools

В этой задаче вам предстоит реализовать несколько вспомогательных функций для
работы с последовательностями, подобных тем, что [реализованы](https://en.cppreference.com/w/cpp/ranges.html#Range_adaptors) в стандартной библиотеке.

А именно `Range`, `Zip` и `Group`.
Примеры того, что мы хотим получить в итоге:

```cpp
std::vector first = {4, 5};
std::list<std::string> second = {"aba", "caba"};

for (const auto& elem : Zip(first, second)) {
    // elem.first -> int
    // elem.second -> string
}

for (const auto& elem : Zip(second, Range(second.size()))) {
    // like enumerate
    // elem.first -> string
    // elem.second -> index: 0, 1, 2, ...
}

for (const auto& elem : Group(first)) {
    // elem groups equal elements
    for (const auto& val : elem) {
        // only equal elements here
    }
}
```

Важно то, что все эти функции не создают новых контейнеров, векторов и прочего.
Все реализуется посредством итераторов, т.е. `Range(100'500)` не создает вектор из кучи элементов,
а возвращает некоторую сущность, по которой можно проитерироваться.

В качестве такой сущности используйте `Sequence`, определенный в `itertools.h`.
Это шаблон класса, содержащего в себе пару итераторов (на начало и на конец последовательности).
Основное его назначение - возвращать из функции как результат, который потом можно
использовать в range-based for (как в примерах выше).

Функция `Range(from, to, step)` должна порождать последовательность `from, from + step, ..., from + k * step`, где `k` --- такое
наибольшее число, что `from + k * step < to`.
Реализуйте также сокращенные формы `Range` с 1 и 2 аргументами (см. тесты).
Считайте, что `step` положительный.

Функция `Zip` принимает 2 последовательности (у каждой из которых есть `begin` и `end`)
и порождает последовательность соответствующих пар.
При этом функция должна обрезать итоговую последовательность до наименьшей, т.е.

```cpp
std::vector a = {1, 2, 3};
for (const auto& val : Zip(a, Range(1 << 30))) {
    // 3 итерации
}
```

Функция `Group` возвращает последовательность из `Sequence` на идущие подряд подпоследовательности из равных элементов (см. тесты).
Для сравнения используйте только оператор `==`.

Все что мы хотим - чтобы работал range-based for,
поэтому вы можете реализовывать минимальный интерфейс у всех итераторов: конструктор,
префиксный ++, разыменование и оператор !=.

### Примечания
* Чтобы не умереть от количества ошибок компиляции, используйте `const` везде где только можно.
В этой задаче подразумевается read-only работа с последовательностями.
* В возвращаемом значении функции можно использовать `auto`, чтобы не писать длинный тип руками.
* В качестве примера в файле [`itertools.h`](itertools.h) приведена реализация функции `Repeat`.
С её помощью  можно в одном цикле `n` раз обойти последовательность:
```cpp
std::list a = {1, 2, 3, 4};
for (auto x : Repeat(a, 3)) {
    // 12 итераций: {1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4}
}
```
* Полезно посмотреть во что раскрывается [range-based for](https://en.cppreference.com/w/cpp/language/range-for#Explanation)
* Использовать `std::ranges` или `std::views` запрещено.
