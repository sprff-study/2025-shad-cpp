# Умные указатели
В этой задаче вам нужно реализовать свои аналоги [`std::shared_ptr`](https://en.cppreference.com/w/cpp/memory/shared_ptr.html) и [`std::weak_ptr`](https://en.cppreference.com/w/cpp/memory/weak_ptr.html). В качестве объекта выступает
`std::string`.

## Shared ptr
Это умный указатель, который можно копировать, и все копии "разделяют" один и тот же объект. Помимо сырого указателя на хранимый объект, внутри shared_ptr есть указатель на "контрольный блок" (тоже выделяется на куче). Этот блок устроен довольно просто - хранит 2 счётчика: количество shared_ptr'ов и weak_ptr'ов, которые ссылаются на данный объект. Соответственно, при копировании объекта указателя увеличивается только счётчик. Когда для данного объекта заканчивается время жизни последнего shared_ptr'а, он уничтожает и сам объект. **Важно**: контрольный блок уничтожается в тот момент, когда **оба счётчика** становятся равны 0.

## Weak ptr
Основное отличие этого указателя от shared_ptr'а в том, что он не владеющий. Это значит, что даже когда объект разрушен (на него больше не ссылается ни одного shared_ptr'а), weak_ptr'ы ещё могут жить. Именно поэтому "контрольный блок" уничтожается последним ссылающимся на него объектом указателя, будь то shared_ptr или weak_ptr.

Чтобы использовать объект через weak_ptr, нужно сделать [lock](https://en.cppreference.com/w/cpp/memory/weak_ptr/lock.html), который создаст нужный shared_ptr, если объект ещё жив. Основная задача weak_ptr'а - решать кольцевые ссылки, которые могут образовывать shared_ptr'ы и тем самым вызывать утечку памяти.

~~Авторам задачи лень описывать требования к интерфейсу~~ В этой задаче мы используем принцип TDD
(Test-Driven Development) -
реализуйте все необходимые методы, чтобы прошли тесты.
