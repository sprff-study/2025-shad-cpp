# Коровий вектор

Стандартный вектор реализует, так называемую, **value-семантику**. Это
значит, что при копировании вектора копируются все значения, хранящиеся
в векторе. Такое поведение называют еще "глубокое копирование".

Семантика копирования вектора проста для понимания, но может быть довольно
затратной. Поэтому при работе с вектором нужно писать код аккуратно,
чтобы не создавались лишние копии вектора там где это не нужно.

Кроме `value-семантики`, можно выделить два других подхода.
 - **reference-семантика** - при копировании объекта, его содержимое никогда
   не копируется, а всегда делится между всеми копиями. Этот подход иногда
   называют "поверхностное копирование" или "shallow copy".
 - **cow-семантика**. **COW** расшифровывается как **"copy-on-write"**. В этом
   подходе мы изначально делаем shallow copy вектора. Если пользователь
   только читает содержимое копии и никак её не модифицирует, то он
   и не замечает подмены и мы экономим затраты. В тот момент, когда
   пользователь пытается совершить модификацию вектора, мы делаем настоящую
   "глубокую копию". Таким образом, копирование совершается только при
   записи в вектор. Отсюда и название "copy-on-write".

## Реализация

Для реализации COW семантики вам потребуется вынести все поля вашего вектора
в отдельную структуру. Внутри этой структуры, кроме обычных полей нужно хранить
еще счётчик ссылок.

```cpp
struct State {
    size_t ref_count; // сколько векторов делят этот State между собой.
    
    std::vector<std::string> data;  // сами данные
};

class COWVector {
public:
    COWVector();
    ~COWVector();

    COWVector(const COWVector& other);
    COWVector& operator=(const COWVector& other);

    size_t Size() const;
    void Resize(size_t size);
    void PushBack(const std::string& value);

    const std::string& Get(size_t at) const;
    const std::string& Back() const;

    void Set(size_t at, const std::string& value);

private:
    State* state_;
};
```

Правильно поддерживая `ref_count` вы всегда будете знать, когда нужно удалять
`State` или когда нужно превращать shallow-copy в deep-copy.
